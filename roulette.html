<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Plinko Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            font-family: Arial, sans-serif;
            background-color: #1a1a2e;
            color: white;
            overflow: hidden;
            touch-action: manipulation;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            padding: 10px 15px;
            background-color: #16213e;
        }
        
        .back-btn {
            color: white;
            text-decoration: none;
            font-size: 14px;
            padding: 4px 8px;
            border-radius: 4px;
            background-color: #0f3460;
        }
        
        .game-wrapper {
            width: 100%;
            height: calc(100% - 90px);
            display: flex;
            justify-content: center;
            padding: 5px;
        }
        
        .game-container {
            position: relative;
            width: 95%;
            height: 100%;
            background-color: #1a1a2e;
            overflow: hidden;
            border: 2px solid #4cc9f0;
            border-radius: 8px;
        }
        
        .peg {
            position: absolute;
            width: 3px;
            height: 3px;
            background-color: #4cc9f0;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
        }
        
        .ball {
            position: absolute;
            width: 5px;
            height: 5px;
            background: radial-gradient(circle at 30% 30%, #fff, #f72585);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 3px rgba(247, 37, 133, 0.7);
            z-index: 2;
        }
        
        .bucket {
            position: absolute;
            bottom: 0;
            height: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 8px;
            color: white;
            background-color: rgba(15, 52, 96, 0.7);
            border: 1px solid #4cc9f0;
            z-index: 3;
        }
        
        .bucket-center {
            border-left: none;
            border-right: none;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            padding: 8px;
            background-color: #16213e;
        }
        
        .drop-btn {
            padding: 8px 16px;
            font-size: 12px;
            background: linear-gradient(135deg, #f72585, #7209b7);
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .result {
            text-align: center;
            padding: 6px;
            font-size: 12px;
            font-weight: bold;
            color: #4cc9f0;
            height: 15px;
            background-color: #16213e;
        }
    </style>
</head>
<body>
    <div class="header">
        <a href="index.html" class="back-btn">Назад</a>
        <div class="result" id="result"></div>
    </div>
    
    <div class="game-wrapper">
        <div class="game-container" id="gameContainer"></div>
    </div>
    
    <div class="controls">
        <button class="drop-btn" id="dropBall">Запустить</button>
    </div>

    <script>
        // Инициализация игры
        const gameContainer = document.getElementById('gameContainer');
        const dropBallBtn = document.getElementById('dropBall');
        const resultDisplay = document.getElementById('result');
        
        // Размеры контейнера
        const containerWidth = gameContainer.offsetWidth;
        const containerHeight = gameContainer.offsetHeight;
        
        // Коэффициенты (симметричные, увеличиваются к краям)
        const multipliers = [10, 7, 5, 3, 2, 1.5, 1.2, 1, 1.2, 1.5, 2, 3, 5, 7, 10];
        const bucketCount = multipliers.length;
        const bucketWidth = containerWidth / bucketCount;
        
        // Создание ячеек с коэффициентами
        for (let i = 0; i < bucketCount; i++) {
            const bucket = document.createElement('div');
            bucket.className = 'bucket';
            if (i > 0 && i < bucketCount - 1) bucket.classList.add('bucket-center');
            bucket.style.width = `${bucketWidth}px`;
            bucket.style.left = `${i * bucketWidth}px`;
            bucket.textContent = `x${multipliers[i]}`;
            gameContainer.appendChild(bucket);
        }
        
        // Создание плотного симметричного поля с препятствиями
        const pegRows = 10;
        const pegVerticalSpacing = (containerHeight - 60) / pegRows;
        const centerX = containerWidth / 2;
        
        for (let row = 0; row < pegRows; row++) {
            // Увеличенное количество препятствий в ряду для плотности
            const pegsInRow = 7 + Math.floor(row * 0.8);
            const pegSpacing = containerWidth / (pegsInRow + 1);
            
            // Смещение для создания симметричного узора
            const offset = row % 2 === 0 ? pegSpacing / 2 : 0;
            
            for (let col = 0; col < pegsInRow; col++) {
                const peg = document.createElement('div');
                peg.className = 'peg';
                
                // Симметричное расположение
                const x = offset + col * pegSpacing;
                const y = 20 + row * pegVerticalSpacing;
                
                peg.style.left = `${x}px`;
                peg.style.top = `${y}px`;
                gameContainer.appendChild(peg);
                
                // Зеркальное отражение для симметрии
                if (x < centerX) {
                    const mirrorPeg = document.createElement('div');
                    mirrorPeg.className = 'peg';
                    mirrorPeg.style.left = `${containerWidth - x}px`;
                    mirrorPeg.style.top = `${y}px`;
                    gameContainer.appendChild(mirrorPeg);
                }
            }
        }
        
        // Физические параметры
        const gravity = 0.3;
        const friction = 0.98;
        const bounce = 0.85;
        const pegRadius = 1.5;
        const ballRadius = 2.5;
        
        // Массив активных шариков
        const balls = [];
        let lastDropTime = 0;
        const dropCooldown = 200; // 0.2s в миллисекундах
        
        // Функция создания нового шарика
        function createBall() {
            const now = Date.now();
            if (now - lastDropTime < dropCooldown) return;
            lastDropTime = now;
            
            const ball = document.createElement('div');
            ball.className = 'ball';
            
            // Старт из центра с небольшим случайным отклонением
            const startX = containerWidth / 2 + (Math.random() - 0.5) * 20;
            ball.style.left = `${startX}px`;
            ball.style.top = '10px';
            
            gameContainer.appendChild(ball);
            
            // Начальная скорость с небольшим случайным отклонением
            const velocity = {
                x: (Math.random() - 0.5) * 1.0,
                y: 0
            };
            
            const state = {
                element: ball,
                x: startX,
                y: 10,
                vx: velocity.x,
                vy: velocity.y,
                active: true,
                lastMoveTime: now,
                stuckCount: 0
            };
            
            balls.push(state);
            return state;
        }
        
        // Оптимизированная проверка столкновений
        function checkCollisions(ball) {
            const pegs = document.querySelectorAll('.peg');
            const minDist = ballRadius + pegRadius;
            const minDistSq = minDist * minDist;
            
            pegs.forEach(peg => {
                const pegX = parseFloat(peg.style.left);
                const pegY = parseFloat(peg.style.top);
                
                const dx = ball.x - pegX;
                const dy = ball.y - pegY;
                const distanceSq = dx * dx + dy * dy;
                
                if (distanceSq < minDistSq) {
                    const distance = Math.sqrt(distanceSq);
                    const nx = dx / distance;
                    const ny = dy / distance;
                    
                    const dotProduct = ball.vx * nx + ball.vy * ny;
                    ball.vx -= 2 * dotProduct * nx * bounce;
                    ball.vy -= 2 * dotProduct * ny * bounce;
                    
                    // Коррекция позиции
                    const overlap = minDist - distance;
                    ball.x += nx * overlap * 0.7;
                    ball.y += ny * overlap * 0.7;
                }
            });
        }
        
        // Проверка попадания в ячейку
        function checkBucketCollision(ball) {
            if (ball.y > containerHeight - 20 && ball.vy > 0) {
                const bucketIndex = Math.min(bucketCount - 1, Math.floor(ball.x / bucketWidth));
                const multiplier = multipliers[bucketIndex];
                
                resultDisplay.textContent = `Выигрыш: x${multiplier}`;
                return true;
            }
            return false;
        }
        
        // Проверка и исправление "застрявших" шариков
        function checkStuckBalls() {
            const now = Date.now();
            const stuckThreshold = 1000; // 1 секунда без движения
            
            for (let i = 0; i < balls.length; i++) {
                const ball = balls[i];
                
                // Если шарик почти не двигается
                if (Math.abs(ball.vx) < 0.01 && Math.abs(ball.vy) < 0.01) {
                    ball.stuckCount++;
                    
                    // Если шарик застрял более чем на 10 кадров
                    if (ball.stuckCount > 10) {
                        // Придаем толчок вниз
                        ball.vy = 0.5;
                        ball.stuckCount = 0;
                    }
                } else {
                    ball.stuckCount = 0;
                }
                
                // Если шарик не двигался дольше порогового значения
                if (now - ball.lastMoveTime > stuckThreshold) {
                    // Принудительно перемещаем вниз
                    ball.y += 2;
                    ball.vy = 0.5;
                    ball.lastMoveTime = now;
                }
            }
        }
        
        // Основной игровой цикл
        function gameLoop() {
            const now = Date.now();
            
            // Проверяем застрявшие шарики
            checkStuckBalls();
            
            for (let i = balls.length - 1; i >= 0; i--) {
                const ball = balls[i];
                
                if (!ball.active) continue;
                
                // Физика движения
                ball.vy += gravity;
                ball.vx *= friction;
                ball.vy *= friction;
                
                // Сохраняем старую позицию для проверки движения
                const oldX = ball.x;
                const oldY = ball.y;
                
                ball.x += ball.vx;
                ball.y += ball.vy;
                
                // Если позиция изменилась, обновляем время последнего движения
                if (Math.abs(oldX - ball.x) > 0.01 || Math.abs(oldY - ball.y) > 0.01) {
                    ball.lastMoveTime = now;
                }
                
                // Границы поля
                if (ball.x < ballRadius) {
                    ball.x = ballRadius;
                    ball.vx = -ball.vx * bounce;
                } else if (ball.x > containerWidth - ballRadius) {
                    ball.x = containerWidth - ballRadius;
                    ball.vx = -ball.vx * bounce;
                }
                
                // Проверка столкновений
                checkCollisions(ball);
                
                // Обновление позиции
                ball.element.style.left = `${ball.x}px`;
                ball.element.style.top = `${ball.y}px`;
                
                // Проверка попадания в ячейку
                if (checkBucketCollision(ball)) {
                    ball.active = false;
                    setTimeout(() => {
                        gameContainer.removeChild(ball.element);
                        balls.splice(i, 1);
                    }, 150);
                }
                
                // Удаление вылетевших шариков
                if (ball.y > containerHeight + 20) {
                    gameContainer.removeChild(ball.element);
                    balls.splice(i, 1);
                }
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Обработчики событий
        dropBallBtn.addEventListener('click', createBall);
        
        // Запуск игры
        gameLoop();
    </script>
</body>
</html>
